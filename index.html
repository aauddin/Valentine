<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Valentine Quest</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f1a; display:grid; place-items:center; height:100vh; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { width:min(960px, 96vw); position:relative; }
    canvas { width:100%; image-rendering: pixelated; border-radius:14px; box-shadow: 0 20px 60px rgba(0,0,0,.45); background:#0b0f1a; display:block; }
    .hud { display:flex; gap:10px; justify-content:space-between; align-items:center; margin:10px 2px 0; opacity:.92; font-size:14px; flex-wrap:wrap; }
    .kbd { border:1px solid rgba(255,255,255,.18); padding:2px 8px; border-radius:8px; display:inline-block; }

    /* Start overlay (solves music blocking reliably) */
    .overlay {
      position:absolute; inset:0;
      display:grid; place-items:center;
      background: rgba(0,0,0,0.65);
      border-radius:14px;
    }
    .panel {
      width:min(520px, 92%);
      background: rgba(10,14,26,0.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:18px 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,.35);
      text-align:center;
    }
    .panel h1 { margin:0 0 8px; font-size:18px; letter-spacing:0.5px; }
    .panel p { margin:6px 0; opacity:.9; font-size:14px; line-height:1.35; }
    .btn {
      margin-top:12px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:white;
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
    }
    .btn:active { transform: translateY(1px); }
    .small { font-size:12px; opacity:.75; margin-top:10px; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="480" height="270"></canvas>

  <!-- Background music -->
  <audio id="bgm" src="assets/music.mp3" loop preload="auto"></audio>

  <!-- Start overlay -->
  <div id="overlay" class="overlay">
    <div class="panel">
      <h1>Valentine Quest üíó</h1>
      <p>Press <b>Start</b> to enable music and begin.</p>
      <p><span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> move &nbsp; <span class="kbd">Space</span> jump &nbsp; <span class="kbd">‚Üì</span> interact</p>
      <button id="startBtn" class="btn">Start</button>
      <div class="small">If music is quiet, turn your device volume up a bit.</div>
    </div>
  </div>

  <div class="hud">
    <div>
      <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> move
      &nbsp; <span class="kbd">Space</span> jump
      &nbsp; <span class="kbd">‚Üì</span> interact
    </div>
    <div id="status">Loading‚Ä¶</div>
  </div>
</div>

<script>
(() => {
  // ======== Customize ========
  const GIRLFRIEND_NAME = "Araya";
  const YOUR_NAME = "Bruce";
  const FINAL_LINE = `Happy Valentine's Day, ${GIRLFRIEND_NAME}. I choose you ‚Äî always.`;
  const SUB_LINE   = `‚Äî ${YOUR_NAME}`;

  const MEMORIES = [
    "Memory #1: The moment I realized you felt like home.",
    "Memory #2: Our inside jokes that still make me grin.",
    "Memory #3: The future I keep building in my head‚Ä¶ with you in it."
  ];

  // Assets (paths already confirmed working for you)
  const PRINCESS_PATH = "assets/Princess.png";
  const PRINCE_PATH   = "assets/Prince.png";

  // ======== Canvas ========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  const statusEl = document.getElementById("status");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");

  // ======== Music (must start on explicit click/tap) ========
  const bgm = document.getElementById("bgm");
  bgm.volume = 0.5;

  // ======== Input ========
  const keys = new Set();
  let justPressedInteract = false;

  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === "ArrowDown") justPressedInteract = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ======== World ========
  const TS = 16;
  const W = 30, H = 17;

  // 0 empty, 1 solid, 2 signpost, 3 heart, 4 gate
  const map = [
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000003000",
    "000000000000000000000000011100",
    "000000000000000200000000000000",
    "000000000000011110000000000000",
    "000000000000000000000003000000",
    "000000000111100000000111100000",
    "000000000000000000000000000000",
    "000000030000000000200000000000",
    "000011110000000001111000000400",
    "000000000000000000000000001111",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "011111111111111111111111111110",
    "111111111111111111111111111111",
  ].map(row => row.split("").map(ch => Number(ch)));

  const signText = [
    `Distance is a map, not a wall.`,
    `Collect the hearts to unlock the gate.`,
    `Every jump is me choosing you again.`
  ];
  let signIndex = 0;

  const collectibles = [];
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 3) collectibles.push({ x, y, taken:false, id: collectibles.length });
    }
  }

  let gate = { x:-1, y:-1, open:false };
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 4) gate = { x, y, open:false };
    }
  }

  // ======== Player ========
  const player = {
    x: 2*TS, y: 12*TS,
    w: 12, h: 14,
    vx: 0, vy: 0,
    onGround: false,
    facingLeft: false
  };

  const physics = { grav: 900, move: 220, jump: 360, friction: 0.85 };
  const cam = { x:0, y:0 };

  // ======== Dialogue bubble ========
  let bubble = { text:"", t:0, show:false };
  function showBubble(text, seconds=2.6){
    bubble.text = text;
    bubble.t = seconds;
    bubble.show = true;
  }

  // ======== Helpers ========
  function isSolid(t){ return t === 1; }
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ======== Sprites (robust load checks) ========
  function loadImage(src){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok:true });
      img.onerror = () => resolve({ img, ok:false });
      img.src = src;
    });
  }

  let princessImg, princeImg;
  let princessOk=false, princeOk=false;

  // We will auto-detect sprite size from the PNG itself
  let princessW=16, princessH=16;
  let princeW=16, princeH=16;

  // ======== Render helpers ========
  function clear(){
    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    for (let i=0;i<40;i++){
      const sx = (i*73) % canvas.width;
      const sy = (i*41) % canvas.height;
      ctx.fillRect(sx, sy, 1, 1);
    }
  }

  function drawTile(x,y,t){
    const px = x*TS - cam.x;
    const py = y*TS - cam.y;

    if (t===1){
      ctx.fillStyle = "#1b2a4a";
      ctx.fillRect(px, py, TS, TS);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(px+2, py+2, TS-4, TS-4);
    } else if (t===2){
      ctx.fillStyle = "#a98b5a";
      ctx.fillRect(px+7, py+3, 2, 10);
      ctx.fillStyle = "#d8c49b";
      ctx.fillRect(px+4, py+2, 8, 5);
    } else if (t===4){
      ctx.fillStyle = gate.open ? "#9de38f" : "#ff9aa9";
      ctx.fillRect(px+3, py+3, TS-6, TS-6);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(px+6, py+6, TS-12, TS-12);
    }
  }

  function drawHeart(px, py, taken){
    if (taken) return;
    const hx = px - cam.x + 4;
    const hy = py - cam.y + 4;
    ctx.fillStyle = "#ff5c7a";
    const pixels = [
      "..xx.xx..",
      ".xxxxxxx.",
      "xxxxxxxxx",
      "xxxxxxxxx",
      ".xxxxxxx.",
      "..xxxxx..",
      "...xxx..."
    ];
    for (let y=0; y<pixels.length; y++){
      for (let x=0; x<pixels[y].length; x++){
        if (pixels[y][x] === "x") ctx.fillRect(hx + x, hy + y, 1, 1);
      }
    }
  }

  // Draw the entire sprite image (no cropping assumptions)
  function drawSprite(img, ok, w, h, dx, dy, facingLeft=false, bob=0){
    if (!ok || !img || img.naturalWidth === 0) {
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.fillRect(dx, dy, TS, TS);
      return;
    }

    ctx.save();
    if (facingLeft){
      ctx.translate(dx + w, dy + bob);
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0, w, h, 0, 0, w, h);
    } else {
      ctx.drawImage(img, 0, 0, w, h, dx, dy + bob, w, h);
    }
    ctx.restore();
  }

  function drawPlayer(){
    const px = Math.floor(player.x - cam.x);
    const py = Math.floor(player.y - cam.y);

    if (player.vx < -5) player.facingLeft = true;
    if (player.vx >  5) player.facingLeft = false;

    const bob = player.onGround ? (Math.sin(performance.now()/280) * 1.2) : 0;

    // Center sprite over collision box a bit
    const dx = px - Math.floor((princessW - player.w)/2);
    const dy = py - Math.floor((princessH - player.h)/2);

    drawSprite(princessImg, princessOk, princessW, princessH, dx, dy, player.facingLeft, bob);
  }

  function drawPrinceAtGate(){
    if (gate.x < 0) return;

    const gx = gate.x*TS - cam.x;
    const gy = gate.y*TS - cam.y;

    const spotX = Math.floor(gx - princeW - 2);
    const spotY = Math.floor(gy - (princeH - TS));

    const bob = Math.sin(performance.now()/320) * 0.8;

    // Face toward player: if prince is right of player, face left, else right
    const princeScreenX = spotX;
    const playerScreenX = (player.x - cam.x);
    const faceLeft = princeScreenX > playerScreenX;

    drawSprite(princeImg, princeOk, princeW, princeH, spotX, spotY, faceLeft, bob);
  }

  function wrapText(text, maxWidth){
    const words = text.split(" ");
    const lines = [];
    let line = "";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    for (const w of words){
      const test = line ? (line + " " + w) : w;
      if (ctx.measureText(test).width > maxWidth && line){
        lines.push(line);
        line = w;
      } else line = test;
    }
    if (line) lines.push(line);
    return lines;
  }

  function roundRect(x, y, w, h, r, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawBubble(){
    if (!bubble.show) return;

    const padding = 8;
    const maxW = 360;
    const lines = wrapText(bubble.text, maxW);
    const lineH = 16;
    const boxW = Math.min(maxW, Math.max(...lines.map(l => ctx.measureText(l).width))) + padding*2;
    const boxH = lines.length*lineH + padding*2;

    const bx = 10, by = 10;

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    roundRect(bx, by, boxW, boxH, 10, true, false);

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    roundRect(bx, by, boxW, boxH, 10, false, true);

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    for (let i=0; i<lines.length; i++){
      ctx.fillText(lines[i], bx+padding, by+padding + (i+1)*lineH - 4);
    }
  }

  // ======== Game state ========
  let heartsCollected = 0;
  let finished = false;
  let started = false;

  function updateStatus(extra=""){
    const imgStatus = `P:${princessOk ? "ok" : "no"} ${princessW}x${princessH} ‚Ä¢ R:${princeOk ? "ok" : "no"} ${princeW}x${princeH}`;
    const audStatus = `Audio:${(!started ? "off" : (bgm.paused ? "paused" : "playing"))}`;
    statusEl.textContent = finished
      ? "Reunited üíû"
      : `Hearts ${heartsCollected}/${collectibles.length} ‚Ä¢ ${audStatus} ‚Ä¢ ${imgStatus}${extra ? " ‚Ä¢ "+extra : ""}`;
  }

  function resolveCollisions(axis){
    const left = Math.floor(player.x / TS);
    const right = Math.floor((player.x + player.w) / TS);
    const top = Math.floor(player.y / TS);
    const bottom = Math.floor((player.y + player.h) / TS);

    if (axis === "y") player.onGround = false;

    for (let y = top; y <= bottom; y++){
      for (let x = left; x <= right; x++){
        const t = (x<0||y<0||x>=W||y>=H) ? 1 : map[y][x];
        if (!isSolid(t)) continue;

        const tx = x*TS;
        const ty = y*TS;

        if (aabb(player.x, player.y, player.w, player.h, tx, ty, TS, TS)){
          if (axis === "x"){
            if (player.vx > 0) player.x = tx - player.w - 0.01;
            else if (player.vx < 0) player.x = tx + TS + 0.01;
            player.vx = 0;
          } else {
            if (player.vy > 0){
              player.y = ty - player.h - 0.01;
              player.vy = 0;
              player.onGround = true;
            } else if (player.vy < 0){
              player.y = ty + TS + 0.01;
              player.vy = 0;
            }
          }
        }
      }
    }
  }

  function handlePickups(){
    for (const h of collectibles){
      if (h.taken) continue;
      const px = h.x*TS, py = h.y*TS;
      if (aabb(player.x, player.y, player.w, player.h, px+3, py+3, TS-6, TS-6)){
        h.taken = true;
        heartsCollected++;
        showBubble(MEMORIES[h.id] ?? "A memory collected.", 3.2);

        if (heartsCollected >= collectibles.length){
          gate.open = true;
          showBubble(`The gate opened. Come to me, ${GIRLFRIEND_NAME}.`, 3.0);
        }
      }
    }
  }

  function handleSignposts(){
    const cx = Math.floor((player.x + player.w/2)/TS);
    const cy = Math.floor((player.y + player.h/2)/TS);

    for (let y=cy-1; y<=cy+1; y++){
      for (let x=cx-1; x<=cx+1; x++){
        if (x<0||y<0||x>=W||y>=H) continue;
        if (map[y][x] === 2 && justPressedInteract){
          showBubble(signText[signIndex % signText.length], 2.6);
          signIndex++;
        }
      }
    }
  }

  function handleGate(){
    if (!gate.open) return;
    const gx = gate.x*TS, gy = gate.y*TS;
    if (aabb(player.x, player.y, player.w, player.h, gx, gy, TS, TS)){
      finished = true;
    }
  }

  function drawEnding(){
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "20px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const title = "REUNITED";
    ctx.fillText(title, (canvas.width - ctx.measureText(title).width)/2, 62);

    // sprites
    const midX = canvas.width/2;
    const y = 76;
    const gap = 12;

    if (princessOk) ctx.drawImage(princessImg, 0,0, princessW, princessH, Math.floor(midX - gap - princessW), y, princessW, princessH);
    if (princeOk)   ctx.drawImage(princeImg,   0,0, princeW,   princeH,   Math.floor(midX + gap), y, princeW, princeH);

    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const lines = wrapText(FINAL_LINE, 360);
    const baseY = 140;
    for (let i=0;i<lines.length;i++){
      const w = ctx.measureText(lines[i]).width;
      ctx.fillText(lines[i], (canvas.width-w)/2, baseY + i*18);
    }

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    const w2 = ctx.measureText(SUB_LINE).width;
    ctx.fillText(SUB_LINE, (canvas.width-w2)/2, baseY + lines.length*18 + 26);
  }

  function step(dt){
    if (!started || finished) return;

    const left  = keys.has("a") || keys.has("arrowleft");
    const right = keys.has("d") || keys.has("arrowright");
    const jump  = keys.has(" ");

    if (left)  player.vx = -physics.move;
    if (right) player.vx = physics.move;
    if (!left && !right) player.vx *= physics.friction;

    if (jump && player.onGround){
      player.vy = -physics.jump;
      player.onGround = false;
    }

    player.vy += physics.grav * dt;

    player.x += player.vx * dt;
    resolveCollisions("x");

    player.y += player.vy * dt;
    resolveCollisions("y");

    cam.x = Math.max(0, Math.min(player.x - canvas.width/2 + player.w/2, W*TS - canvas.width));
    cam.y = Math.max(0, Math.min(player.y - canvas.height/2 + player.h/2, H*TS - canvas.height));

    if (bubble.show){
      bubble.t -= dt;
      if (bubble.t <= 0) bubble.show = false;
    }

    handlePickups();
    handleSignposts();
    handleGate();

    updateStatus();
    justPressedInteract = false;
  }

  function draw(){
    clear();

    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const t = map[y][x];
        if (t===0 || t===3) continue;
        drawTile(x,y,t);
      }
    }

    for (const h of collectibles) drawHeart(h.x*TS, h.y*TS, h.taken);

    // Prince waiting near the gate
    drawPrinceAtGate();

    // Player
    drawPlayer();

    drawBubble();

    if (finished) drawEnding();
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ======== Start button: loads sprites + starts music + begins game ========
  startBtn.addEventListener("click", async () => {
    // Load images explicitly so we KNOW their dimensions
    const p1 = await loadImage(PRINCESS_PATH);
    princessImg = p1.img; princessOk = p1.ok;
    princessW = princessImg.naturalWidth || 16;
    princessH = princessImg.naturalHeight || 16;

    const p2 = await loadImage(PRINCE_PATH);
    princeImg = p2.img; princeOk = p2.ok;
    princeW = princeImg.naturalWidth || 16;
    princeH = princeImg.naturalHeight || 16;

    // Start audio (this click is a guaranteed user gesture)
    try {
      bgm.currentTime = 0;
      await bgm.play();
    } catch (e) {
      // If it fails, we still start the game, but show it in the HUD
      updateStatus("Audio blocked");
    }

    started = true;
    overlay.style.display = "none";
    showBubble(`Hi ${GIRLFRIEND_NAME} üíó Collect the hearts. Then come to me.`, 3.2);
    updateStatus();
  });

  // Kick off render loop (draws even before start)
  updateStatus("Press Start");
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
