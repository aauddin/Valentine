<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Valentine Quest</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f1a; display:grid; place-items:center; height:100vh; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { width:min(960px, 96vw); }
    canvas { width:100%; image-rendering: pixelated; border-radius:14px; box-shadow: 0 20px 60px rgba(0,0,0,.45); background:#0b0f1a; }
    .hud { display:flex; gap:10px; justify-content:space-between; align-items:center; margin:10px 2px 0; opacity:.92; font-size:14px; flex-wrap:wrap; }
    .kbd { border:1px solid rgba(255,255,255,.18); padding:2px 8px; border-radius:8px; display:inline-block; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="480" height="270"></canvas>

  <!-- Background music: put file at /assets/music.mp3 -->
  <audio id="bgm" src="assets/music.mp3" loop preload="auto"></audio>

  <div class="hud">
    <div>
      <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> move
      &nbsp; <span class="kbd">Space</span> jump
      &nbsp; <span class="kbd">‚Üì</span> interact
    </div>
    <div id="status">Loading love‚Ä¶</div>
  </div>
</div>

<script>
(() => {
  // ======== Customize ========
  const GIRLFRIEND_NAME = "Araya";   // change
  const YOUR_NAME = "Bruce";         // change
  const FINAL_LINE = `Happy Valentine's Day, ${GIRLFRIEND_NAME}. I choose you ‚Äî always.`;
  const SUB_LINE   = `‚Äî ${YOUR_NAME}`;

  // Replace with real memories (these pop up when hearts are collected)
  const MEMORIES = [
    "Memory #1: The moment I realized you felt like home.",
    "Memory #2: Our inside jokes that still make me grin.",
    "Memory #3: The future I keep building in my head‚Ä¶ with you in it."
  ];

  // Assets (case-sensitive on Netlify)
  const PRINCESS_PATH = "assets/Princess.png";
  const PRINCE_PATH   = "assets/Prince.png";
  const MUSIC_VOLUME  = 0.35;

  // Sprite size (set to 16 if these are 16x16 sprites)
  const SPR = 16;

  // ======== Canvas ========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;
  const statusEl = document.getElementById("status");

  // ======== Music (starts on first interaction; browsers block autoplay) ========
  const bgm = document.getElementById("bgm");
  let bgmStarted = false;
  function startBgm(){
    if (bgmStarted) return;
    bgmStarted = true;
    bgm.volume = MUSIC_VOLUME;
    bgm.play().catch(()=>{ /* if blocked, next interaction tries again */ });
  }
  window.addEventListener("pointerdown", startBgm, { passive:true });
  window.addEventListener("keydown", startBgm, { passive:true });

  // ======== Input ========
  const keys = new Set();
  let justPressedInteract = false;

  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === "ArrowDown") justPressedInteract = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ======== World ========
  const TS = 16;
  const W = 30, H = 17;

  // 0 empty, 1 solid, 2 signpost, 3 heart, 4 gate
  const map = [
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000003000",
    "000000000000000000000000011100",
    "000000000000000200000000000000",
    "000000000000011110000000000000",
    "000000000000000000000003000000",
    "000000000111100000000111100000",
    "000000000000000000000000000000",
    "000000030000000000200000000000",
    "000011110000000001111000000400",
    "000000000000000000000000001111",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "011111111111111111111111111110",
    "111111111111111111111111111111",
  ].map(row => row.split("").map(ch => Number(ch)));

  const signText = [
    `Distance is a map, not a wall.`,
    `Collect the hearts to unlock the gate.`,
    `Every jump is me choosing you again.`
  ];
  let signIndex = 0;

  const collectibles = [];
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 3) collectibles.push({ x, y, taken:false, id: collectibles.length });
    }
  }

  let gate = { x:-1, y:-1, open:false };
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 4) gate = { x, y, open:false };
    }
  }

  // ======== Player (Princess) ========
  const player = {
    x: 2*TS, y: 12*TS,
    w: 12, h: 14,
    vx: 0, vy: 0,
    onGround: false,
    facingLeft: false
  };

  const physics = {
    grav: 900,
    move: 220,
    jump: 360,
    friction: 0.85
  };

  // ======== Camera ========
  const cam = { x:0, y:0 };

  // ======== Dialogue bubble ========
  let bubble = { text:"", t:0, show:false };
  function showBubble(text, seconds=2.6){
    bubble.text = text;
    bubble.t = seconds;
    bubble.show = true;
  }

  // ======== Helpers ========
  function isSolid(t){ return t === 1; }
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ======== Sprites ========
  const princessImg = new Image();
  princessImg.src = PRINCESS_PATH;

  const princeImg = new Image();
  princeImg.src = PRINCE_PATH;

  // ======== Render ========
  function clear(){
    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    for (let i=0;i<40;i++){
      const sx = (i*73) % canvas.width;
      const sy = (i*41) % canvas.height;
      ctx.fillRect(sx, sy, 1, 1);
    }
  }

  function drawTile(x,y,t){
    const px = x*TS - cam.x;
    const py = y*TS - cam.y;

    if (t===1){
      ctx.fillStyle = "#1b2a4a";
      ctx.fillRect(px, py, TS, TS);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(px+2, py+2, TS-4, TS-4);
    } else if (t===2){
      // signpost
      ctx.fillStyle = "#a98b5a";
      ctx.fillRect(px+7, py+3, 2, 10);
      ctx.fillStyle = "#d8c49b";
      ctx.fillRect(px+4, py+2, 8, 5);

      // tiny hint pixel
      ctx.fillStyle = "rgba(255,255,255,0.55)";
      ctx.fillRect(px+12, py+1, 2, 2);
    } else if (t===4){
      // gate
      ctx.fillStyle = gate.open ? "#9de38f" : "#ff9aa9";
      ctx.fillRect(px+3, py+3, TS-6, TS-6);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(px+6, py+6, TS-12, TS-12);
    }
  }

  function drawHeart(px, py, taken){
    if (taken) return;
    const hx = px - cam.x + 4;
    const hy = py - cam.y + 4;
    ctx.fillStyle = "#ff5c7a";
    const pixels = [
      "..xx.xx..",
      ".xxxxxxx.",
      "xxxxxxxxx",
      "xxxxxxxxx",
      ".xxxxxxx.",
      "..xxxxx..",
      "...xxx..."
    ];
    for (let y=0; y<pixels.length; y++){
      for (let x=0; x<pixels[y].length; x++){
        if (pixels[y][x] === "x") ctx.fillRect(hx + x, hy + y, 1, 1);
      }
    }
  }

  function drawSprite(img, dx, dy, facingLeft=false, bob=0){
    if (!img.complete) {
      ctx.fillStyle = "rgba(255,255,255,0.25)";
      ctx.fillRect(dx, dy, SPR, SPR);
      return;
    }
    ctx.save();
    if (facingLeft){
      ctx.translate(dx + SPR, dy + bob);
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0, SPR, SPR, 0, 0, SPR, SPR);
    } else {
      ctx.drawImage(img, 0, 0, SPR, SPR, dx, dy + bob, SPR, SPR);
    }
    ctx.restore();
  }

  function drawPlayer(){
    const px = Math.floor(player.x - cam.x);
    const py = Math.floor(player.y - cam.y);

    if (player.vx < -5) player.facingLeft = true;
    if (player.vx >  5) player.facingLeft = false;

    const bob = player.onGround ? (Math.sin(performance.now()/280) * 1.2) : 0;
    drawSprite(princessImg, px, py, player.facingLeft, bob);
  }

  function drawPrinceAtGate(){
    // Draw prince standing near the gate (for the "reunion" moment)
    if (gate.x < 0) return;
    const gx = gate.x*TS - cam.x;
    const gy = gate.y*TS - cam.y;

    // Put him just left of the gate if possible, otherwise just right
    const leftSpotX = gx - SPR - 2;
    const rightSpotX = gx + TS + 2;
    const spotX = (leftSpotX >= 0) ? leftSpotX : rightSpotX;

    const bob = Math.sin(performance.now()/320) * 0.8;
    // Face toward the center / toward player (roughly)
    const faceLeft = (spotX > (player.x - cam.x));
    drawSprite(princeImg, Math.floor(spotX), Math.floor(gy - (SPR - TS)), faceLeft, bob);
  }

  function wrapText(text, maxWidth){
    const words = text.split(" ");
    const lines = [];
    let line = "";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    for (const w of words){
      const test = line ? (line + " " + w) : w;
      if (ctx.measureText(test).width > maxWidth && line){
        lines.push(line);
        line = w;
      } else line = test;
    }
    if (line) lines.push(line);
    return lines;
  }

  function roundRect(x, y, w, h, r, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  function drawBubble(){
    if (!bubble.show) return;
    const padding = 8;
    const maxW = 360;

    const lines = wrapText(bubble.text, maxW);
    const lineH = 16;
    const boxW = Math.min(maxW, Math.max(...lines.map(l => ctx.measureText(l).width))) + padding*2;
    const boxH = lines.length*lineH + padding*2;

    const bx = 10, by = 10;

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    roundRect(bx, by, boxW, boxH, 10, true, false);

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    roundRect(bx, by, boxW, boxH, 10, false, true);

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    for (let i=0; i<lines.length; i++){
      ctx.fillText(lines[i], bx+padding, by+padding + (i+1)*lineH - 4);
    }
  }

  // ======== Game state ========
  let heartsCollected = 0;
  let finished = false;

  function updateStatus(){
    statusEl.textContent = finished
      ? "Reunited üíû"
      : `Hearts: ${heartsCollected}/${collectibles.length}  ‚Ä¢  Gate: ${gate.open ? "Open" : "Locked"}`;
  }

  // ======== Collisions ========
  function resolveCollisions(axis){
    const left = Math.floor(player.x / TS);
    const right = Math.floor((player.x + player.w) / TS);
    const top = Math.floor(player.y / TS);
    const bottom = Math.floor((player.y + player.h) / TS);

    if (axis === "y") player.onGround = false;

    for (let y = top; y <= bottom; y++){
      for (let x = left; x <= right; x++){
        const t = (x<0||y<0||x>=W||y>=H) ? 1 : map[y][x];
        if (!isSolid(t)) continue;

        const tx = x*TS;
        const ty = y*TS;

        if (aabb(player.x, player.y, player.w, player.h, tx, ty, TS, TS)){
          if (axis === "x"){
            if (player.vx > 0) player.x = tx - player.w - 0.01;
            else if (player.vx < 0) player.x = tx + TS + 0.01;
            player.vx = 0;
          } else {
            if (player.vy > 0){
              player.y = ty - player.h - 0.01;
              player.vy = 0;
              player.onGround = true;
            } else if (player.vy < 0){
              player.y = ty + TS + 0.01;
              player.vy = 0;
            }
          }
        }
      }
    }
  }

  // ======== Interactions ========
  function handlePickups(){
    for (const h of collectibles){
      if (h.taken) continue;
      const px = h.x*TS, py = h.y*TS;
      if (aabb(player.x, player.y, player.w, player.h, px+3, py+3, TS-6, TS-6)){
        h.taken = true;
        heartsCollected++;
        showBubble(MEMORIES[h.id] ?? "A memory collected.", 3.2);

        if (heartsCollected >= collectibles.length){
          gate.open = true;
          showBubble(`The gate opened. Come to me, ${GIRLFRIEND_NAME}.`, 3.0);
        }
      }
    }
  }

  function handleSignposts(){
    const cx = Math.floor((player.x + player.w/2)/TS);
    const cy = Math.floor((player.y + player.h/2)/TS);

    for (let y=cy-1; y<=cy+1; y++){
      for (let x=cx-1; x<=cx+1; x++){
        if (x<0||y<0||x>=W||y>=H) continue;
        if (map[y][x] === 2 && justPressedInteract){
          showBubble(signText[signIndex % signText.length], 2.6);
          signIndex++;
        }
      }
    }
  }

  function handleGate(){
    if (!gate.open) return;
    const gx = gate.x*TS, gy = gate.y*TS;
    if (aabb(player.x, player.y, player.w, player.h, gx, gy, TS, TS)){
      finished = true;
    }
  }

  // ======== Ending screen ========
  function drawEnding(){
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Title
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.font = "20px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const title = "REUNITED";
    ctx.fillText(title, (canvas.width - ctx.measureText(title).width)/2, 62);

    // Show both sprites under the title
    const midX = canvas.width/2;
    const y = 78;
    const gap = 10;

    // Princess (left)
    if (princessImg.complete) ctx.drawImage(princessImg, 0,0,SPR,SPR, Math.floor(midX - SPR - gap), y, SPR, SPR);
    // Prince (right)
    if (princeImg.complete) ctx.drawImage(princeImg, 0,0,SPR,SPR, Math.floor(midX + gap), y, SPR, SPR);

    // Message
    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const lines = wrapText(FINAL_LINE, 360);
    const baseY = 135;
    for (let i=0;i<lines.length;i++){
      const w = ctx.measureText(lines[i]).width;
      ctx.fillText(lines[i], (canvas.width-w)/2, baseY + i*18);
    }

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    const w2 = ctx.measureText(SUB_LINE).width;
    ctx.fillText(SUB_LINE, (canvas.width-w2)/2, baseY + lines.length*18 + 26);

    ctx.fillStyle = "rgba(255,255,255,0.6)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const hint = "Refresh to play again.";
    ctx.fillText(hint, (canvas.width - ctx.measureText(hint).width)/2, canvas.height-30);
  }

  // ======== Game loop ========
  function step(dt){
    if (finished) return;

    const left  = keys.has("a") || keys.has("arrowleft");
    const right = keys.has("d") || keys.has("arrowright");
    const jump  = keys.has(" ");

    if (left)  player.vx = -physics.move;
    if (right) player.vx = physics.move;
    if (!left && !right) player.vx *= physics.friction;

    if (jump && player.onGround){
      player.vy = -physics.jump;
      player.onGround = false;
    }

    player.vy += physics.grav * dt;

    player.x += player.vx * dt;
    resolveCollisions("x");

    player.y += player.vy * dt;
    resolveCollisions("y");

    // camera follow
    cam.x = Math.max(0, Math.min(player.x - canvas.width/2 + player.w/2, W*TS - canvas.width));
    cam.y = Math.max(0, Math.min(player.y - canvas.height/2 + player.h/2, H*TS - canvas.height));

    // bubble timer
    if (bubble.show){
      bubble.t -= dt;
      if (bubble.t <= 0) bubble.show = false;
    }

    handlePickups();
    handleSignposts();
    handleGate();

    updateStatus();
    justPressedInteract = false;
  }

  function draw(){
    clear();

    // tiles
    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const t = map[y][x];
        if (t===0 || t===3) continue;
        drawTile(x,y,t);
      }
    }

    // hearts
    for (const h of collectibles) drawHeart(h.x*TS, h.y*TS, h.taken);

    // prince near the gate (always visible, cute ‚Äúwaiting‚Äù)
    drawPrinceAtGate();

    // player
    drawPlayer();

    // UI bubble
    drawBubble();

    if (finished) drawEnding();
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Start
  updateStatus();
  showBubble(`Hi ${GIRLFRIEND_NAME} üíó Collect the hearts. Then come to me.`, 3.2);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
