<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Valentine Quest</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f1a; display:grid; place-items:center; height:100vh; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    .wrap { width:min(960px, 96vw); position:relative; }
    canvas { width:100%; image-rendering: pixelated; border-radius:14px; box-shadow: 0 20px 60px rgba(0,0,0,.45); background:#0b0f1a; display:block; }
    .hud { display:flex; gap:10px; justify-content:space-between; align-items:center; margin:10px 2px 0; opacity:.92; font-size:14px; flex-wrap:wrap; }
    .kbd { border:1px solid rgba(255,255,255,.18); padding:2px 8px; border-radius:8px; display:inline-block; }

    .overlay {
      position:absolute; inset:0;
      display:grid; place-items:center;
      background: rgba(0,0,0,0.65);
      border-radius:14px;
    }
    .panel {
      width:min(560px, 92%);
      background: rgba(10,14,26,0.92);
      border:1px solid rgba(255,255,255,.12);
      border-radius:14px;
      padding:18px 16px;
      text-align:center;
    }
    .panel h1 { margin:0 0 8px; font-size:18px; letter-spacing:0.5px; }
    .panel p { margin:6px 0; opacity:.9; font-size:14px; line-height:1.35; }
    .row { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px; }
    .btn {
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color:white;
      padding:10px 14px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
    }
    .btn:active { transform: translateY(1px); }
    .small { font-size:12px; opacity:.75; margin-top:10px; }
  </style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="480" height="270"></canvas>

  <!-- Update only if your files are NOT in assets/ -->
  <audio id="bgm" src="assets/music.mp3" loop preload="auto"></audio>

  <div id="overlay" class="overlay">
    <div class="panel">
      <h1>Valentine Quest üíó</h1>
      <p>We‚Äôre going to force-load sprites + force-start music.</p>
      <p><span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> move &nbsp; <span class="kbd">Space</span> jump &nbsp; <span class="kbd">‚Üì</span> interact</p>
      <div class="row">
        <button id="startBtn" class="btn">Start Game</button>
        <button id="musicBtn" class="btn">Start Music</button>
      </div>
      <div class="small" id="startNote">If music says ‚Äúblocked‚Äù, tap Start Music again.</div>
    </div>
  </div>

  <div class="hud">
    <div>
      <span class="kbd">A</span><span class="kbd">D</span> / <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> move
      &nbsp; <span class="kbd">Space</span> jump
      &nbsp; <span class="kbd">‚Üì</span> interact
    </div>
    <div id="status">Loading‚Ä¶</div>
  </div>
</div>

<script>
(() => {
  // ======== Customize ========
  const GIRLFRIEND_NAME = "Araya";
  const YOUR_NAME = "Bruce";
  const FINAL_LINE = `Happy Valentine's Day, ${GIRLFRIEND_NAME}. I choose you ‚Äî always.`;
  const SUB_LINE   = `‚Äî ${YOUR_NAME}`;

  const MEMORIES = [
    "Memory #1: The moment I realized you felt like home.",
    "Memory #2: Our inside jokes that still make me grin.",
    "Memory #3: The future I keep building in my head‚Ä¶ with you in it."
  ];

  // Assets (you said the URLs work)
  const PRINCESS_PATH = "assets/Princess.png";
  const PRINCE_PATH   = "assets/Prince.png";

  // ======== Canvas ========
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  ctx.imageSmoothingEnabled = false;

  const statusEl = document.getElementById("status");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");
  const musicBtn = document.getElementById("musicBtn");
  const startNote = document.getElementById("startNote");

  // ======== Audio ========
  const bgm = document.getElementById("bgm");
  bgm.volume = 0.55;

  async function tryPlayMusic(){
    try {
      // Some browsers like a "reset" before play
      if (bgm.readyState < 2) {
        // force load
        bgm.load();
      }
      const p = bgm.play();
      if (p && typeof p.then === "function") await p;
      return { ok:true, msg:"playing" };
    } catch (e) {
      return { ok:false, msg:"blocked/paused" };
    }
  }

  musicBtn.addEventListener("click", async () => {
    const res = await tryPlayMusic();
    startNote.textContent = res.ok ? "Music is playing ‚úÖ" : "Music is blocked/paused ‚ùó Tap Start Music again (or unmute your device).";
  });

  // ======== Input ========
  const keys = new Set();
  let justPressedInteract = false;

  window.addEventListener("keydown", (e) => {
    if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"," "].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if (e.key === "ArrowDown") justPressedInteract = true;
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  // ======== World ========
  const TS = 16;
  const W = 30, H = 17;

  const map = [
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "000000000000000000000000003000",
    "000000000000000000000000011100",
    "000000000000000200000000000000",
    "000000000000011110000000000000",
    "000000000000000000000003000000",
    "000000000111100000000111100000",
    "000000000000000000000000000000",
    "000000030000000000200000000000",
    "000011110000000001111000000400",
    "000000000000000000000000001111",
    "000000000000000000000000000000",
    "000000000000000000000000000000",
    "011111111111111111111111111110",
    "111111111111111111111111111111",
  ].map(row => row.split("").map(ch => Number(ch)));

  const signText = [
    `Distance is a map, not a wall.`,
    `Collect the hearts to unlock the gate.`,
    `Every jump is me choosing you again.`
  ];
  let signIndex = 0;

  const collectibles = [];
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 3) collectibles.push({ x, y, taken:false, id: collectibles.length });
    }
  }

  let gate = { x:-1, y:-1, open:false };
  for (let y=0; y<H; y++){
    for (let x=0; x<W; x++){
      if (map[y][x] === 4) gate = { x, y, open:false };
    }
  }

  // ======== Player ========
  const player = {
    x: 2*TS, y: 12*TS,
    w: 12, h: 14,
    vx: 0, vy: 0,
    onGround: false,
    facingLeft: false
  };

  const physics = { grav: 900, move: 220, jump: 360, friction: 0.85 };
  const cam = { x:0, y:0 };

  // ======== Bubble ========
  let bubble = { text:"", t:0, show:false };
  function showBubble(text, seconds=2.6){
    bubble.text = text;
    bubble.t = seconds;
    bubble.show = true;
  }

  // ======== Helpers ========
  function isSolid(t){ return t === 1; }
  function aabb(ax, ay, aw, ah, bx, by, bw, bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ======== Image loading with explicit flags ========
  function loadImage(src){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ img, ok:true });
      img.onerror = () => resolve({ img, ok:false });
      // If this ever *is* a CORS issue, this helps:
      img.crossOrigin = "anonymous";
      img.src = src;
    });
  }

  let princessImg=null, princeImg=null;
  let princessOk=false, princeOk=false;

  function dims(img){ return { w: img?.naturalWidth||0, h: img?.naturalHeight||0 }; }

  // ======== Rendering ========
  function clear(){
    ctx.fillStyle = "#0b0f1a";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    for (let i=0;i<40;i++){
      const sx = (i*73) % canvas.width;
      const sy = (i*41) % canvas.height;
      ctx.fillRect(sx, sy, 1, 1);
    }
  }

  function drawTile(x,y,t){
    const px = x*TS - cam.x;
    const py = y*TS - cam.y;

    if (t===1){
      ctx.fillStyle = "#1b2a4a";
      ctx.fillRect(px, py, TS, TS);
      ctx.fillStyle = "rgba(255,255,255,0.06)";
      ctx.fillRect(px+2, py+2, TS-4, TS-4);
    } else if (t===2){
      ctx.fillStyle = "#a98b5a";
      ctx.fillRect(px+7, py+3, 2, 10);
      ctx.fillStyle = "#d8c49b";
      ctx.fillRect(px+4, py+2, 8, 5);
    } else if (t===4){
      ctx.fillStyle = gate.open ? "#9de38f" : "#ff9aa9";
      ctx.fillRect(px+3, py+3, TS-6, TS-6);
      ctx.fillStyle = "rgba(0,0,0,0.25)";
      ctx.fillRect(px+6, py+6, TS-12, TS-12);
    }
  }

  function drawHeart(px, py, taken){
    if (taken) return;
    const hx = px - cam.x + 4;
    const hy = py - cam.y + 4;
    ctx.fillStyle = "#ff5c7a";
    const pixels = [
      "..xx.xx..",
      ".xxxxxxx.",
      "xxxxxxxxx",
      "xxxxxxxxx",
      ".xxxxxxx.",
      "..xxxxx..",
      "...xxx..."
    ];
    for (let y=0; y<pixels.length; y++){
      for (let x=0; x<pixels[y].length; x++){
        if (pixels[y][x] === "x") ctx.fillRect(hx + x, hy + y, 1, 1);
      }
    }
  }

  // Draw image at full size (no crop assumptions) with optional flip
  function drawImageSprite(img, ok, dx, dy, facingLeft=false, bob=0){
    if (!ok || !img || img.naturalWidth === 0) return;

    const w = img.naturalWidth, h = img.naturalHeight;

    ctx.save();
    if (facingLeft){
      ctx.translate(dx + w, dy + bob);
      ctx.scale(-1, 1);
      ctx.drawImage(img, 0, 0, w, h, 0, 0, w, h);
    } else {
      ctx.drawImage(img, 0, 0, w, h, dx, dy + bob, w, h);
    }
    ctx.restore();
  }

  function drawPlayer(){
    const px = Math.floor(player.x - cam.x);
    const py = Math.floor(player.y - cam.y);

    if (player.vx < -5) player.facingLeft = true;
    if (player.vx >  5) player.facingLeft = false;

    const bob = player.onGround ? (Math.sin(performance.now()/280) * 1.2) : 0;

    // anchor: place sprite bottom aligned with collision box bottom
    if (princessOk && princessImg){
      const w = princessImg.naturalWidth, h = princessImg.naturalHeight;
      const dx = px - Math.floor((w - player.w)/2);
      const dy = (py + player.h) - h; // bottom align
      drawImageSprite(princessImg, true, dx, dy, player.facingLeft, bob);
    }
  }

  function drawPrinceAtGate(){
    if (!princeOk || !princeImg || gate.x < 0) return;
    const gx = gate.x*TS - cam.x;
    const gy = gate.y*TS - cam.y;

    const w = princeImg.naturalWidth, h = princeImg.naturalHeight;

    // put prince left of gate, bottom aligned to ground tile
    const dx = Math.floor(gx - w - 4);
    const dy = Math.floor((gy + TS) - h);

    const playerScreenX = player.x - cam.x;
    const faceLeft = dx > playerScreenX;

    const bob = Math.sin(performance.now()/320) * 0.8;
    drawImageSprite(princeImg, true, dx, dy, faceLeft, bob);
  }

  function drawDebugPreview(){
    // Always draw previews in top-right so you KNOW if they‚Äôre loading
    const pad = 6;
    let x = canvas.width - pad;

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.fillRect(canvas.width - 150, 0, 150, 80);

    ctx.fillStyle = "rgba(255,255,255,0.75)";
    ctx.font = "10px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.fillText("DEBUG PREVIEW", canvas.width - 145, 12);

    if (princessOk && princessImg && princessImg.naturalWidth){
      const w = princessImg.naturalWidth, h = princessImg.naturalHeight;
      x -= w;
      ctx.drawImage(princessImg, 0,0,w,h, x, 18, w, h);
      ctx.fillText(`P ${w}x${h}`, x, 18 + h + 10);
      x -= pad;
    } else {
      ctx.fillText("Princess not loaded", canvas.width - 145, 28);
    }

    if (princeOk && princeImg && princeImg.naturalWidth){
      const w = princeImg.naturalWidth, h = princeImg.naturalHeight;
      const px = canvas.width - 145;
      ctx.drawImage(princeImg, 0,0,w,h, px, 44, Math.min(w, 32), Math.min(h, 32));
      ctx.fillText(`R ${w}x${h}`, px + 38, 62);
    } else {
      ctx.fillText("Prince not loaded", canvas.width - 145, 44);
    }
  }

  function drawBubble(){
    if (!bubble.show) return;

    const padding = 8;
    const maxW = 360;

    const words = bubble.text.split(" ");
    const lines = [];
    let line = "";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    for (const w of words){
      const test = line ? (line + " " + w) : w;
      if (ctx.measureText(test).width > maxW && line){
        lines.push(line); line = w;
      } else line = test;
    }
    if (line) lines.push(line);

    const lineH = 16;
    const boxW = Math.min(maxW, Math.max(...lines.map(l => ctx.measureText(l).width))) + padding*2;
    const boxH = lines.length*lineH + padding*2;

    const bx = 10, by = 10;

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    roundRect(bx, by, boxW, boxH, 10, true, false);

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    roundRect(bx, by, boxW, boxH, 10, false, true);

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    for (let i=0; i<lines.length; i++){
      ctx.fillText(lines[i], bx+padding, by+padding + (i+1)*lineH - 4);
    }
  }

  function roundRect(x, y, w, h, r, fill, stroke){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ======== Game state ========
  let heartsCollected = 0;
  let finished = false;
  let started = false;

  function updateHud(){
    const p = princessImg ? `${princessImg.naturalWidth||0}x${princessImg.naturalHeight||0}` : "0x0";
    const r = princeImg ? `${princeImg.naturalWidth||0}x${princeImg.naturalHeight||0}` : "0x0";
    const aud = (!started ? "off" : (bgm.paused ? "paused" : "playing"));
    statusEl.textContent = `Hearts ${heartsCollected}/${collectibles.length} ‚Ä¢ Audio:${aud} ‚Ä¢ P:${princessOk?"ok":"no"} ${p} ‚Ä¢ R:${princeOk?"ok":"no"} ${r}`;
  }

  function resolveCollisions(axis){
    const left = Math.floor(player.x / TS);
    const right = Math.floor((player.x + player.w) / TS);
    const top = Math.floor(player.y / TS);
    const bottom = Math.floor((player.y + player.h) / TS);

    if (axis === "y") player.onGround = false;

    for (let y = top; y <= bottom; y++){
      for (let x = left; x <= right; x++){
        const t = (x<0||y<0||x>=W||y>=H) ? 1 : map[y][x];
        if (!isSolid(t)) continue;

        const tx = x*TS;
        const ty = y*TS;

        if (aabb(player.x, player.y, player.w, player.h, tx, ty, TS, TS)){
          if (axis === "x"){
            if (player.vx > 0) player.x = tx - player.w - 0.01;
            else if (player.vx < 0) player.x = tx + TS + 0.01;
            player.vx = 0;
          } else {
            if (player.vy > 0){
              player.y = ty - player.h - 0.01;
              player.vy = 0;
              player.onGround = true;
            } else if (player.vy < 0){
              player.y = ty + TS + 0.01;
              player.vy = 0;
            }
          }
        }
      }
    }
  }

  function handlePickups(){
    for (const h of collectibles){
      if (h.taken) continue;
      const px = h.x*TS, py = h.y*TS;
      if (aabb(player.x, player.y, player.w, player.h, px+3, py+3, TS-6, TS-6)){
        h.taken = true;
        heartsCollected++;
        showBubble(MEMORIES[h.id] ?? "A memory collected.", 3.2);

        if (heartsCollected >= collectibles.length){
          gate.open = true;
          showBubble(`The gate opened. Come to me, ${GIRLFRIEND_NAME}.`, 3.0);
        }
      }
    }
  }

  function handleSignposts(){
    const cx = Math.floor((player.x + player.w/2)/TS);
    const cy = Math.floor((player.y + player.h/2)/TS);

    for (let y=cy-1; y<=cy+1; y++){
      for (let x=cx-1; x<=cx+1; x++){
        if (x<0||y<0||x>=W||y>=H) continue;
        if (map[y][x] === 2 && justPressedInteract){
          showBubble(signText[signIndex % signText.length], 2.6);
          signIndex++;
        }
      }
    }
  }

  function handleGate(){
    if (!gate.open) return;
    const gx = gate.x*TS, gy = gate.y*TS;
    if (aabb(player.x, player.y, player.w, player.h, gx, gy, TS, TS)){
      finished = true;
    }
  }

  function step(dt){
    if (!started || finished) return;

    const left  = keys.has("a") || keys.has("arrowleft");
    const right = keys.has("d") || keys.has("arrowright");
    const jump  = keys.has(" ");

    if (left)  player.vx = -physics.move;
    if (right) player.vx = physics.move;
    if (!left && !right) player.vx *= physics.friction;

    if (jump && player.onGround){
      player.vy = -physics.jump;
      player.onGround = false;
    }

    player.vy += physics.grav * dt;

    player.x += player.vx * dt; resolveCollisions("x");
    player.y += player.vy * dt; resolveCollisions("y");

    cam.x = Math.max(0, Math.min(player.x - canvas.width/2 + player.w/2, W*TS - canvas.width));
    cam.y = Math.max(0, Math.min(player.y - canvas.height/2 + player.h/2, H*TS - canvas.height));

    if (bubble.show){
      bubble.t -= dt;
      if (bubble.t <= 0) bubble.show = false;
    }

    handlePickups();
    handleSignposts();
    handleGate();

    updateHud();
    justPressedInteract = false;
  }

  function draw(){
    clear();

    for (let y=0;y<H;y++){
      for (let x=0;x<W;x++){
        const t = map[y][x];
        if (t===0 || t===3) continue;
        drawTile(x,y,t);
      }
    }

    for (const h of collectibles) drawHeart(h.x*TS, h.y*TS, h.taken);

    drawPrinceAtGate();
    drawPlayer();
    drawBubble();

    // ALWAYS show debug previews (top-right)
    drawDebugPreview();
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // ======== Start button: force-load images, then start music, then start game ========
  startBtn.addEventListener("click", async () => {
    const p1 = await loadImage(PRINCESS_PATH);
    princessImg = p1.img; princessOk = p1.ok;

    const p2 = await loadImage(PRINCE_PATH);
    princeImg = p2.img; princeOk = p2.ok;

    // If image load failed, we show it clearly in HUD
    updateHud();

    // Start music (this click is user gesture)
    const res = await tryPlayMusic();
    startNote.textContent = res.ok ? "Music is playing ‚úÖ" : "Music is blocked/paused ‚ùó Tap Start Music again (or unmute device).";

    started = true;
    overlay.style.display = "none";
    showBubble(`Hi ${GIRLFRIEND_NAME} üíó Collect the hearts. Then come to me.`, 3.0);
  });

  updateHud();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
